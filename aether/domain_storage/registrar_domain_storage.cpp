/*
 * Copyright 2024 Aethernet Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "aether/domain_storage/registrar_domain_storage.h"

#if defined REGISTRAR_DOMAIN_STORAGE_ENABLED

#  include <fstream>
#  include <string_view>
#  include <system_error>

#  include "aether/format/format.h"

#  include "aether/tele/tele.h"

namespace ae {

RegistrarDomainStorage::RegistrarDomainStorage(std::filesystem::path file_path)
    : file_path_{std::move(file_path)} {
  AE_TELED_DEBUG("New RegistrarDomainFacility instance created!");
}

RegistrarDomainStorage::~RegistrarDomainStorage() {
  SaveState();
  AE_TELED_DEBUG("RegistrarDomainFacility instance deleted!");
}

std::unique_ptr<IDomainStorageWriter> RegistrarDomainStorage::Store(
    DataKey key, std::uint8_t version) {
  return ram_storage.Store(key, version);
}

DomainLoad RegistrarDomainStorage::Load(DataKey key, std::uint8_t version) {
  return ram_storage.Load(key, version);
}

void RegistrarDomainStorage::Remove(DataKey key) { ram_storage.Remove(key); }

void RegistrarDomainStorage::CleanUp() { ram_storage.CleanUp(); }

void RegistrarDomainStorage::SaveState() {
  static constexpr std::string_view preamble =
      "/**\n * This file is autogenerated by aether-registrator\n */"
      "\n\n#ifndef FILE_SYSTEM_STATE_H_"
      "\n#define FILE_SYSTEM_STATE_H_\n\n"
      "#include \"aether/domain_storage/static_object_types.h\"\n"
      "// clang-format off \n";
  static constexpr std::string_view epilogue =
      "// clang-format on\n"
      "\n#endif // FILE_SYSTEM_STATE_H_";

  AE_TELED_DEBUG("Save state to a file {}", file_path_.string());

  std::error_code ec;
  auto file = std::ofstream{file_path_, std::ios::out | std::ios::binary};

  file << preamble;

  // write list of data arrays
  for (auto const& [key, version_data] : ram_storage.state) {
    if (!version_data) {
      continue;
    }
    for (auto const& [version, data] : *version_data) {
      Format(file,
             "static constexpr auto data_array_{}_{} = "
             "std::array<std::uint8_t, {}>{",
             key, static_cast<int>(version), data.size());
      PrintData(file, data);
      file << "};\n";
    }
  }

  file << "\n";

  // write map
  file << "  ae::StaticMap{{\n";
  for (auto const& [key, version_data] : ram_storage.state) {
    if (!version_data) {
      continue;
    }
    for (auto const& [version, _] : *version_data) {
      file << "    std::pair{ ae::ObjectPathKey{ ";
      Format(file, "{}, {}", key, static_cast<int>(version));
      file << " }, ae::Span{ ";
      Format(file, "data_array_{}_{}", key, static_cast<int>(version));
      file << " }},\n";
    }
  }
  file << "  \n}},\n";
  file << "};\n\n";
  file << epilogue;
}

void RegistrarDomainStorage::PrintData(std::ofstream& file,
                                       std::vector<std::uint8_t> const& data) {
  for (auto const& d : data) {
    file << "0x" << std::setfill('0') << std::setw(2) << std::hex
         << static_cast<std::uint64_t>(d) << ", ";
  }
  file << std::setfill(' ') << std::dec << std::setw(0);
}
}  // namespace ae

#endif  // REGISTRAR_DOMAIN_FACILITY_ENABLED
