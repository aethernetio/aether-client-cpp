/*
 * Copyright 2024 Aethernet Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "aether/domain_storage/registrar_domain_storage.h"

#if defined REGISTRAR_DOMAIN_STORAGE_ENABLED

#  include <fstream>
#  include <string_view>
#  include <system_error>

#  include "aether/format/format.h"

#  include "aether/tele/tele.h"

namespace ae {

RegistrarDomainStorage::RegistrarDomainStorage(std::filesystem::path file_path)
    : file_path_{std::move(file_path)} {
  AE_TELED_DEBUG("New RegistrarDomainFacility instance created!");
}

RegistrarDomainStorage::~RegistrarDomainStorage() {
  SaveState();
  AE_TELED_DEBUG("RegistrarDomainFacility instance deleted!");
}

std::unique_ptr<IDomainStorageWriter> RegistrarDomainStorage::Store(
    DomainQuery const& query) {
  return ram_storage.Store(query);
}

ClassList RegistrarDomainStorage::Enumerate(const ObjId& obj_id) {
  return ram_storage.Enumerate(obj_id);
}

DomainLoad RegistrarDomainStorage::Load(DomainQuery const& query) {
  return ram_storage.Load(query);
}

void RegistrarDomainStorage::Remove(ObjId const& obj_id) {
  ram_storage.Remove(obj_id);
}

void RegistrarDomainStorage::CleanUp() { ram_storage.CleanUp(); }

void RegistrarDomainStorage::SaveState() {
  static constexpr std::string_view preamble =
      "/**\n * This file is autogenerated by aether-registrator\n */"
      "\n\n#ifndef FILE_SYSTEM_STATE_H_"
      "\n#define FILE_SYSTEM_STATE_H_\n\n"
      "#include \"aether/domain_storage/static_object_types.h\"\n"
      "// clang-format off \n";
  static constexpr std::string_view epilogue =
      "// clang-format on\n"
      "\n#endif // FILE_SYSTEM_STATE_H_";

  AE_TELED_DEBUG("Save state to a file {}", file_path_.string());

  std::error_code ec;
  auto file = std::ofstream{file_path_, std::ios::out | std::ios::binary};

  file << preamble;

  // write list of class arrays
  for (auto const& [obj_id, obj_data] : ram_storage.state) {
    if (!obj_data) {
      continue;
    }
    Format(file,
           "static constexpr auto class_array_{} = "
           "std::array<std::uint32_t, {}>{",
           obj_id.ToString(), obj_data->size());
    PrintMapKeysAsData(file, *obj_data);
    file << "};\n";
  }
  file << "\n";

  // write list of data arrays
  for (auto const& [obj_id, obj_data] : ram_storage.state) {
    if (!obj_data) {
      continue;
    }
    for (auto const& [class_id, class_data] : *obj_data) {
      for (auto const& [version, data] : class_data) {
        Format(file,
               "static constexpr auto data_array_{}_{}_{} = "
               "std::array<std::uint8_t, {}>{",
               obj_id.ToString(), class_id, static_cast<int>(version),
               data.size());
        PrintData(file, data);
        file << "};\n";
      }
    }
  }

  file << "\n";
  file << "static constexpr auto static_domain_data = ae::StaticDomainData{\n";

  // write object map
  file << "  ae::StaticMap{{\n";
  for (auto const& [obj_id, obj_data] : ram_storage.state) {
    file << "    std::pair{ std::uint32_t{ " << obj_id.ToString()
         << " } , ae::Span{ class_array_" << obj_id.ToString() << " }},\n";
  }
  file << "  }},\n";

  file << "\n";
  // write map
  file << "  ae::StaticMap{{\n";
  for (auto const& [obj_id, obj_data] : ram_storage.state) {
    if (!obj_data) {
      continue;
    }
    for (auto const& [class_id, class_data] : *obj_data) {
      for (auto const& [version, _] : class_data) {
        file << "    std::pair{ ae::ObjectPathKey{ ";
        Format(file, "{}, {}, {}", obj_id.ToString(), class_id,
               static_cast<int>(version));
        file << " }, ae::Span{ ";
        Format(file, "data_array_{}_{}_{}", obj_id.ToString(), class_id,
               static_cast<int>(version));
        file << " }},\n";
      }
    }
  }
  file << "  \n}},\n";
  file << "};\n\n";
  file << epilogue;
}

void RegistrarDomainStorage::PrintData(std::ofstream& file,
                                       std::vector<std::uint8_t> const& data) {
  for (auto const& d : data) {
    file << "0x" << std::setfill('0') << std::setw(2) << std::hex
         << static_cast<std::uint64_t>(d) << ", ";
  }
  file << std::setfill(' ') << std::dec << std::setw(0);
}

template <typename K, typename T>
void RegistrarDomainStorage::PrintMapKeysAsData(std::ofstream& file,
                                                std::map<K, T> const& map) {
  for (auto const& [k, _] : map) {
    file << static_cast<std::uint64_t>(k) << ", ";
  }
  file << std::setfill(' ') << std::dec << std::setw(0);
}

}  // namespace ae

#endif  // REGISTRAR_DOMAIN_FACILITY_ENABLED
