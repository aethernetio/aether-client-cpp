/*
 * Copyright 2024 Aethernet Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "aether/port/file_systems/file_system_header.h"

#if defined AE_FILE_SYSTEM_HEADER_ENABLED

#  include <fstream>
#  include <string_view>
#  include <system_error>

#  include "aether/format/format.h"

#  include "aether/port/file_systems/file_systems_tele.h"

namespace ae {

FileSystemHeaderFacility::FileSystemHeaderFacility(
    std::filesystem::path file_path)
    : file_path_{std::move(file_path)} {
  AE_TELED_DEBUG("New FileSystemHeader instance created!");
}

FileSystemHeaderFacility::~FileSystemHeaderFacility() {
  AE_TELED_DEBUG("FileSystemHeader instance deleted!");
  SaveState();
}

std::vector<uint32_t> FileSystemHeaderFacility::Enumerate(const ObjId& obj_id) {
  std::vector<uint32_t> classes;

  // Enumerate
  auto it = state_.find(obj_id);
  if (it != state_.end()) {
    auto& obj_classes = it->second;
    AE_TELED_DEBUG("Object id={} found!", obj_id.ToString());
    for (auto const& [class_id, _] : obj_classes) {
      AE_TELED_DEBUG("Add to the classes {}", class_id);
      classes.push_back(class_id);
    }
  }

  return classes;
}

void FileSystemHeaderFacility::Store(const ObjId& obj_id,
                                     std::uint32_t class_id,
                                     std::uint8_t version,
                                     const std::vector<uint8_t>& os) {
  state_[obj_id][class_id][version] = os;

  AE_TELED_DEBUG("Saved state/{}/{}/{} size: {}", std::to_string(version),
                 obj_id.ToString(), class_id, os.size());

  AE_TELED_DEBUG("Object id={} & class id = {} saved!", obj_id.ToString(),
                 class_id);
}

void FileSystemHeaderFacility::Load(const ObjId& obj_id, std::uint32_t class_id,
                                    std::uint8_t version,
                                    std::vector<uint8_t>& is) {
  auto obj_it = state_.find(obj_id);
  if (obj_it == state_.end()) {
    return;
  }

  auto class_it = obj_it->second.find(class_id);
  if (class_it == obj_it->second.end()) {
    return;
  }

  auto version_it = class_it->second.find(version);
  if (version_it == class_it->second.end()) {
    return;
  }

  AE_TELED_DEBUG("Object id={} & class id = {} version {} loaded!",
                 obj_id.ToString(), class_id, version);
  is = version_it->second;

  AE_TELED_DEBUG("Loaded state/{}/{}/{} size: {}", std::to_string(version),
                 obj_id.ToString(), class_id, is.size());
}

void FileSystemHeaderFacility::Remove(const ObjId& obj_id) {
  auto it = state_.find(obj_id);
  if (it != state_.end()) {
    AE_TELED_DEBUG("Object id={} removed!", obj_id.ToString());
    state_.erase(it);
  } else {
    AE_TELED_WARNING("Object id={} not found!", obj_id.ToString());
  }
}

#  if defined AE_DISTILLATION
void FileSystemHeaderFacility::CleanUp() { state_.clear(); }
#  endif

void FileSystemHeaderFacility::SaveState() {
  static constexpr std::string_view preamble =
      "/**\n * This file is autogenerated by aether-registrator\n */"
      "\n\n#ifndef FILE_SYSTEM_STATE_H_"
      "\n#define FILE_SYSTEM_STATE_H_\n\n"
      "#include \"aether/port/file_systems/static_object_types.h\"\n"
      "// clang-format off \n";
  static constexpr std::string_view epilogue =
      "// clang-format on\n"
      "\n#endif // FILE_SYSTEM_STATE_H_";

  AE_TELED_DEBUG("Save state to a file {}", file_path_.string());

  std::error_code ec;
  auto file = std::ofstream{file_path_, std::ios::out | std::ios::binary};

  file << preamble;

  // write list of class arrays
  for (auto const& [obj_id, obj_data] : state_) {
    Format(file,
           "static constexpr auto class_array_{} = "
           "std::array<std::uint32_t, {}>{",
           obj_id.ToString(), obj_data.size());
    PrintMapKeysAsData(file, obj_data);
    file << "};\n";
  }
  file << "\n";

  // write list of data arrays
  for (auto const& [obj_id, obj_data] : state_) {
    for (auto const& [class_id, class_data] : obj_data) {
      for (auto const& [version, data] : class_data) {
        Format(file,
               "static constexpr auto data_array_{}_{}_{} = "
               "std::array<std::uint8_t, {}>{",
               obj_id.ToString(), class_id, static_cast<int>(version),
               data.size());
        PrintData(file, data);
        file << "};\n";
      }
    }
  }

  file << "\n";
  // write object map
  file << "static constexpr auto object_map = ae::StaticMap{{\n";
  for (auto const& [obj_id, obj_data] : state_) {
    file << "  std::pair{ std::uint32_t{ " << obj_id.ToString()
         << " } , ae::Span{ class_array_" << obj_id.ToString() << " }},\n";
  }
  file << "}};\n";

  file << "\n\n";
  // write map
  file << "static constexpr auto state_map = ae::StaticMap{{\n";
  for (auto const& [obj_id, obj_data] : state_) {
    for (auto const& [class_id, class_data] : obj_data) {
      for (auto const& [version, _] : class_data) {
        file << "  std::pair{ ae::ObjectPathKey{ ";
        Format(file, "{}, {}, {}", obj_id.ToString(), class_id,
               static_cast<int>(version));
        file << " }, ae::Span{ ";
        Format(file, "data_array_{}_{}_{}", obj_id.ToString(), class_id,
               static_cast<int>(version));
        file << " }},\n";
      }
    }
  }
  file << "\n}};\n";
  file << "\n";
  file << epilogue;
}

void FileSystemHeaderFacility::PrintData(
    std::ofstream& file, std::vector<std::uint8_t> const& data) {
  for (auto const& d : data) {
    file << "0x" << std::setfill('0') << std::setw(2) << std::hex
         << static_cast<std::uint64_t>(d) << ", ";
  }
  file << std::setfill(' ') << std::dec << std::setw(0);
}

template <typename K, typename T>
void FileSystemHeaderFacility::PrintMapKeysAsData(std::ofstream& file,
                                                  std::map<K, T> const& map) {
  for (auto const& [k, _] : map) {
    file << "0x" << std::setfill('0') << std::setw(2) << std::hex
         << static_cast<std::uint64_t>(k) << ", ";
  }
  file << std::setfill(' ') << std::dec << std::setw(0);
}

}  // namespace ae

#endif  // AE_FILE_SYSTEM_HEADER_ENABLED
